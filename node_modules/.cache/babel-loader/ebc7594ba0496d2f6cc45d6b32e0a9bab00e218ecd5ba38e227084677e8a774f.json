{"ast":null,"code":"\"use strict\";\n\n//TODO:\n// Remove Dict and use native Map as much as possible here\n//Use ObjectChangeDescriptor to avoid creating useless arrays and benefit from similar gains made in property-changes\nvar WeakMap = require(\"../weak-map\"),\n  Map = require(\"../_map\"),\n  ChangeDescriptor = require(\"./change-descriptor\"),\n  ObjectChangeDescriptor = ChangeDescriptor.ObjectChangeDescriptor,\n  ChangeListenersRecord = ChangeDescriptor.ChangeListenersRecord,\n  ListenerGhost = ChangeDescriptor.ListenerGhost;\nvar rangeChangeDescriptors = new WeakMap(); // {isActive, willChangeListeners, changeListeners}\n\n//\nfunction RangeChangeDescriptor(name) {\n  this.name = name;\n  this.isActive = false;\n  this._willChangeListeners = null;\n  this._changeListeners = null;\n}\n;\nRangeChangeDescriptor.prototype = new ObjectChangeDescriptor();\nRangeChangeDescriptor.prototype.constructor = RangeChangeDescriptor;\nRangeChangeDescriptor.prototype.changeListenersRecordConstructor = RangeChangeListenersRecord;\nRangeChangeDescriptor.prototype.willChangeListenersRecordConstructor = RangeWillChangeListenersRecord;\nObject.defineProperty(RangeChangeDescriptor.prototype, \"active\", {\n  get: function () {\n    return this._active || (this._active = this._current ? this._current.slice() : []);\n  }\n});\nvar RangeChangeListenersSpecificHandlerMethodName = new Map();\nfunction RangeChangeListenersRecord(name) {\n  var specificHandlerMethodName = RangeChangeListenersSpecificHandlerMethodName.get(name);\n  if (!specificHandlerMethodName) {\n    specificHandlerMethodName = \"handle\";\n    specificHandlerMethodName += name.slice(0, 1).toUpperCase();\n    specificHandlerMethodName += name.slice(1);\n    specificHandlerMethodName += \"RangeChange\";\n    RangeChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName);\n  }\n  this.specificHandlerMethodName = specificHandlerMethodName;\n  return this;\n}\nRangeChangeListenersRecord.prototype = new ChangeListenersRecord();\nRangeChangeListenersRecord.prototype.constructor = RangeChangeListenersRecord;\nvar RangeWillChangeListenersSpecificHandlerMethodName = new Map();\nfunction RangeWillChangeListenersRecord(name) {\n  var specificHandlerMethodName = RangeWillChangeListenersSpecificHandlerMethodName.get(name);\n  if (!specificHandlerMethodName) {\n    specificHandlerMethodName = \"handle\";\n    specificHandlerMethodName += name.slice(0, 1).toUpperCase();\n    specificHandlerMethodName += name.slice(1);\n    specificHandlerMethodName += \"RangeWillChange\";\n    RangeWillChangeListenersSpecificHandlerMethodName.set(name, specificHandlerMethodName);\n  }\n  this.specificHandlerMethodName = specificHandlerMethodName;\n  return this;\n}\nRangeWillChangeListenersRecord.prototype = new ChangeListenersRecord();\nRangeWillChangeListenersRecord.prototype.constructor = RangeWillChangeListenersRecord;\nmodule.exports = RangeChanges;\nfunction RangeChanges() {\n  throw new Error(\"Can't construct. RangeChanges is a mixin.\");\n}\nRangeChanges.prototype.getAllRangeChangeDescriptors = function () {\n  if (!rangeChangeDescriptors.has(this)) {\n    rangeChangeDescriptors.set(this, new Map());\n  }\n  return rangeChangeDescriptors.get(this);\n};\nRangeChanges.prototype.getRangeChangeDescriptor = function (token) {\n  var tokenChangeDescriptors = this.getAllRangeChangeDescriptors();\n  token = token || \"\";\n  if (!tokenChangeDescriptors.has(token)) {\n    tokenChangeDescriptors.set(token, new RangeChangeDescriptor(token));\n  }\n  return tokenChangeDescriptors.get(token);\n};\nvar ObjectsDispatchesRangeChanges = new WeakMap(),\n  dispatchesRangeChangesGetter = function () {\n    return ObjectsDispatchesRangeChanges.get(this);\n  },\n  dispatchesRangeChangesSetter = function (value) {\n    return ObjectsDispatchesRangeChanges.set(this, value);\n  },\n  dispatchesChangesMethodName = \"dispatchesRangeChanges\",\n  dispatchesChangesPropertyDescriptor = {\n    get: dispatchesRangeChangesGetter,\n    set: dispatchesRangeChangesSetter,\n    configurable: true,\n    enumerable: false\n  };\nRangeChanges.prototype.addRangeChangeListener = function addRangeChangeListener(listener, token, beforeChange) {\n  // a concession for objects like Array that are not inherently observable\n  if (!this.isObservable && this.makeObservable) {\n    this.makeObservable();\n  }\n  var descriptor = this.getRangeChangeDescriptor(token);\n  var listeners;\n  if (beforeChange) {\n    listeners = descriptor.willChangeListeners;\n  } else {\n    listeners = descriptor.changeListeners;\n  }\n\n  // even if already registered\n  if (!listeners._current) {\n    listeners._current = listener;\n  } else if (!Array.isArray(listeners._current)) {\n    listeners._current = [listeners._current, listener];\n  } else {\n    listeners._current.push(listener);\n  }\n  if (Object.getOwnPropertyDescriptor(this.__proto__ || Object.getPrototypeOf(this), dispatchesChangesMethodName) === void 0) {\n    Object.defineProperty(this.__proto__ || Object.getPrototypeOf(this), dispatchesChangesMethodName, dispatchesChangesPropertyDescriptor);\n  }\n  this.dispatchesRangeChanges = true;\n  var self = this;\n  return function cancelRangeChangeListener() {\n    if (!self) {\n      // TODO throw new Error(\"Range change listener \" + JSON.stringify(token) + \" has already been canceled\");\n      return;\n    }\n    self.removeRangeChangeListener(listener, token, beforeChange);\n    self = null;\n  };\n};\nRangeChanges.prototype.removeRangeChangeListener = function (listener, token, beforeChange) {\n  var descriptor = this.getRangeChangeDescriptor(token);\n  var listeners;\n  if (beforeChange) {\n    listeners = descriptor._willChangeListeners;\n  } else {\n    listeners = descriptor._changeListeners;\n  }\n  if (listeners._current) {\n    if (listeners._current === listener) {\n      listeners._current = null;\n    } else {\n      var index = listeners._current.lastIndexOf(listener);\n      if (index === -1) {\n        throw new Error(\"Can't remove range change listener: does not exist: token \" + JSON.stringify(token));\n      } else {\n        if (descriptor.isActive) {\n          listeners.ghostCount = listeners.ghostCount + 1;\n          listeners._current[index] = ListenerGhost;\n        } else {\n          listeners._current.spliceOne(index);\n        }\n      }\n    }\n  }\n};\nRangeChanges.prototype.dispatchRangeChange = function (plus, minus, index, beforeChange) {\n  var descriptors = this.getAllRangeChangeDescriptors(),\n    descriptor,\n    mapIter = descriptors.values(),\n    listeners,\n    tokenName,\n    i,\n    countI,\n    listener,\n    currentListeners,\n    Ghost;\n  descriptors.dispatchBeforeChange = beforeChange;\n  while (descriptor = mapIter.next().value) {\n    if (descriptor.isActive) {\n      return;\n    }\n\n    // before or after\n    listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners;\n    if (listeners && listeners._current) {\n      tokenName = listeners.specificHandlerMethodName;\n      if (Array.isArray(listeners._current)) {\n        if (listeners._current.length) {\n          // notably, defaults to \"handleRangeChange\" or \"handleRangeWillChange\"\n          // if token is \"\" (the default)\n\n          descriptor.isActive = true;\n          // dispatch each listener\n          try {\n            //removeGostListenersIfNeeded returns listeners.current or a new filtered one when conditions are met\n            currentListeners = listeners.removeCurrentGostListenersIfNeeded();\n            Ghost = ListenerGhost;\n            for (i = 0, countI = currentListeners.length; i < countI; i++) {\n              if ((listener = currentListeners[i]) !== Ghost) {\n                if (listener[tokenName]) {\n                  listener[tokenName](plus, minus, index, this, beforeChange);\n                } else if (listener.call) {\n                  listener.call(this, plus, minus, index, this, beforeChange);\n                } else {\n                  throw new Error(\"Handler \" + listener + \" has no method \" + tokenName + \" and is not callable\");\n                }\n              }\n            }\n          } finally {\n            descriptor.isActive = false;\n          }\n        }\n      } else {\n        descriptor.isActive = true;\n        // dispatch each listener\n        try {\n          listener = listeners._current;\n          if (listener[tokenName]) {\n            listener[tokenName](plus, minus, index, this, beforeChange);\n          } else if (listener.call) {\n            listener.call(this, plus, minus, index, this, beforeChange);\n          } else {\n            throw new Error(\"Handler \" + listener + \" has no method \" + tokenName + \" and is not callable\");\n          }\n        } finally {\n          descriptor.isActive = false;\n        }\n      }\n    }\n  }\n};\nRangeChanges.prototype.addBeforeRangeChangeListener = function (listener, token) {\n  return this.addRangeChangeListener(listener, token, true);\n};\nRangeChanges.prototype.removeBeforeRangeChangeListener = function (listener, token) {\n  return this.removeRangeChangeListener(listener, token, true);\n};\nRangeChanges.prototype.dispatchBeforeRangeChange = function (plus, minus, index) {\n  return this.dispatchRangeChange(plus, minus, index, true);\n};","map":{"version":3,"names":["WeakMap","require","Map","ChangeDescriptor","ObjectChangeDescriptor","ChangeListenersRecord","ListenerGhost","rangeChangeDescriptors","RangeChangeDescriptor","name","isActive","_willChangeListeners","_changeListeners","prototype","constructor","changeListenersRecordConstructor","RangeChangeListenersRecord","willChangeListenersRecordConstructor","RangeWillChangeListenersRecord","Object","defineProperty","get","_active","_current","slice","RangeChangeListenersSpecificHandlerMethodName","specificHandlerMethodName","toUpperCase","set","RangeWillChangeListenersSpecificHandlerMethodName","module","exports","RangeChanges","Error","getAllRangeChangeDescriptors","has","getRangeChangeDescriptor","token","tokenChangeDescriptors","ObjectsDispatchesRangeChanges","dispatchesRangeChangesGetter","dispatchesRangeChangesSetter","value","dispatchesChangesMethodName","dispatchesChangesPropertyDescriptor","configurable","enumerable","addRangeChangeListener","listener","beforeChange","isObservable","makeObservable","descriptor","listeners","willChangeListeners","changeListeners","Array","isArray","push","getOwnPropertyDescriptor","__proto__","getPrototypeOf","dispatchesRangeChanges","self","cancelRangeChangeListener","removeRangeChangeListener","index","lastIndexOf","JSON","stringify","ghostCount","spliceOne","dispatchRangeChange","plus","minus","descriptors","mapIter","values","tokenName","i","countI","currentListeners","Ghost","dispatchBeforeChange","next","length","removeCurrentGostListenersIfNeeded","call","addBeforeRangeChangeListener","removeBeforeRangeChangeListener","dispatchBeforeRangeChange"],"sources":["D:/Gits/bomes/node_modules/collections/listen/range-changes.js"],"sourcesContent":["\"use strict\";\n\n//TODO:\n// Remove Dict and use native Map as much as possible here\n//Use ObjectChangeDescriptor to avoid creating useless arrays and benefit from similar gains made in property-changes\n\n\nvar WeakMap = require(\"../weak-map\"),\n    Map = require(\"../_map\"),\n    ChangeDescriptor = require(\"./change-descriptor\"),\n    ObjectChangeDescriptor = ChangeDescriptor.ObjectChangeDescriptor,\n    ChangeListenersRecord = ChangeDescriptor.ChangeListenersRecord,\n    ListenerGhost = ChangeDescriptor.ListenerGhost;\n\nvar rangeChangeDescriptors = new WeakMap(); // {isActive, willChangeListeners, changeListeners}\n\n\n//\nfunction RangeChangeDescriptor(name) {\n    this.name = name;\n    this.isActive = false;\n    this._willChangeListeners = null;\n    this._changeListeners = null;\n};\n\nRangeChangeDescriptor.prototype = new ObjectChangeDescriptor();\nRangeChangeDescriptor.prototype.constructor = RangeChangeDescriptor;\n\nRangeChangeDescriptor.prototype.changeListenersRecordConstructor = RangeChangeListenersRecord;\nRangeChangeDescriptor.prototype.willChangeListenersRecordConstructor = RangeWillChangeListenersRecord;\nObject.defineProperty(RangeChangeDescriptor.prototype,\"active\",{\n    get: function() {\n        return this._active || (this._active = this._current ? this._current.slice():[]);\n    }\n});\n\n\nvar RangeChangeListenersSpecificHandlerMethodName = new Map();\n\nfunction RangeChangeListenersRecord(name) {\n    var specificHandlerMethodName = RangeChangeListenersSpecificHandlerMethodName.get(name);\n    if(!specificHandlerMethodName) {\n        specificHandlerMethodName = \"handle\";\n        specificHandlerMethodName += name.slice(0, 1).toUpperCase();\n        specificHandlerMethodName += name.slice(1);\n        specificHandlerMethodName += \"RangeChange\";\n        RangeChangeListenersSpecificHandlerMethodName.set(name,specificHandlerMethodName);\n    }\n    this.specificHandlerMethodName = specificHandlerMethodName;\n\treturn this;\n}\nRangeChangeListenersRecord.prototype = new ChangeListenersRecord();\nRangeChangeListenersRecord.prototype.constructor = RangeChangeListenersRecord;\n\nvar RangeWillChangeListenersSpecificHandlerMethodName = new Map();\n\nfunction RangeWillChangeListenersRecord(name) {\n    var specificHandlerMethodName = RangeWillChangeListenersSpecificHandlerMethodName.get(name);\n    if(!specificHandlerMethodName) {\n        specificHandlerMethodName = \"handle\";\n        specificHandlerMethodName += name.slice(0, 1).toUpperCase();\n        specificHandlerMethodName += name.slice(1);\n        specificHandlerMethodName += \"RangeWillChange\";\n        RangeWillChangeListenersSpecificHandlerMethodName.set(name,specificHandlerMethodName);\n    }\n    this.specificHandlerMethodName = specificHandlerMethodName;\n    return this;\n}\nRangeWillChangeListenersRecord.prototype = new ChangeListenersRecord();\nRangeWillChangeListenersRecord.prototype.constructor = RangeWillChangeListenersRecord;\n\nmodule.exports = RangeChanges;\nfunction RangeChanges() {\n    throw new Error(\"Can't construct. RangeChanges is a mixin.\");\n}\n\nRangeChanges.prototype.getAllRangeChangeDescriptors = function () {\n    if (!rangeChangeDescriptors.has(this)) {\n        rangeChangeDescriptors.set(this, new Map());\n    }\n    return rangeChangeDescriptors.get(this);\n};\n\nRangeChanges.prototype.getRangeChangeDescriptor = function (token) {\n    var tokenChangeDescriptors = this.getAllRangeChangeDescriptors();\n    token = token || \"\";\n    if (!tokenChangeDescriptors.has(token)) {\n        tokenChangeDescriptors.set(token, new RangeChangeDescriptor(token));\n    }\n    return tokenChangeDescriptors.get(token);\n};\n\nvar ObjectsDispatchesRangeChanges = new WeakMap(),\n    dispatchesRangeChangesGetter = function() {\n        return ObjectsDispatchesRangeChanges.get(this);\n    },\n    dispatchesRangeChangesSetter = function(value) {\n        return ObjectsDispatchesRangeChanges.set(this,value);\n    },\n    dispatchesChangesMethodName = \"dispatchesRangeChanges\",\n    dispatchesChangesPropertyDescriptor = {\n        get: dispatchesRangeChangesGetter,\n        set: dispatchesRangeChangesSetter,\n        configurable: true,\n        enumerable: false\n    };\n\nRangeChanges.prototype.addRangeChangeListener = function addRangeChangeListener(listener, token, beforeChange) {\n    // a concession for objects like Array that are not inherently observable\n    if (!this.isObservable && this.makeObservable) {\n        this.makeObservable();\n    }\n\n    var descriptor = this.getRangeChangeDescriptor(token);\n\n    var listeners;\n    if (beforeChange) {\n        listeners = descriptor.willChangeListeners;\n    } else {\n        listeners = descriptor.changeListeners;\n    }\n\n    // even if already registered\n    if(!listeners._current) {\n        listeners._current = listener;\n    }\n    else if(!Array.isArray(listeners._current)) {\n        listeners._current = [listeners._current,listener]\n    }\n    else {\n        listeners._current.push(listener);\n    }\n\n    if(Object.getOwnPropertyDescriptor((this.__proto__||Object.getPrototypeOf(this)),dispatchesChangesMethodName) === void 0) {\n        Object.defineProperty((this.__proto__||Object.getPrototypeOf(this)), dispatchesChangesMethodName, dispatchesChangesPropertyDescriptor);\n    }\n    this.dispatchesRangeChanges = true;\n\n    var self = this;\n    return function cancelRangeChangeListener() {\n        if (!self) {\n            // TODO throw new Error(\"Range change listener \" + JSON.stringify(token) + \" has already been canceled\");\n            return;\n        }\n        self.removeRangeChangeListener(listener, token, beforeChange);\n        self = null;\n    };\n};\n\n\nRangeChanges.prototype.removeRangeChangeListener = function (listener, token, beforeChange) {\n    var descriptor = this.getRangeChangeDescriptor(token);\n\n    var listeners;\n    if (beforeChange) {\n        listeners = descriptor._willChangeListeners;\n    } else {\n        listeners = descriptor._changeListeners;\n    }\n\n    if(listeners._current) {\n        if(listeners._current === listener) {\n            listeners._current = null;\n        }\n        else {\n            var index = listeners._current.lastIndexOf(listener);\n            if (index === -1) {\n                throw new Error(\"Can't remove range change listener: does not exist: token \" + JSON.stringify(token));\n            }\n            else {\n                if(descriptor.isActive) {\n                    listeners.ghostCount = listeners.ghostCount+1\n                    listeners._current[index]=ListenerGhost\n                }\n                else {\n                    listeners._current.spliceOne(index);\n                }\n            }\n        }\n    }\n\n};\n\nRangeChanges.prototype.dispatchRangeChange = function (plus, minus, index, beforeChange) {\n    var descriptors = this.getAllRangeChangeDescriptors(),\n        descriptor,\n        mapIter  = descriptors.values(),\n        listeners,\n        tokenName,\n        i,\n        countI,\n        listener,\n        currentListeners,\n        Ghost;\n\n    descriptors.dispatchBeforeChange = beforeChange;\n\n     while (descriptor = mapIter.next().value) {\n\n        if (descriptor.isActive) {\n            return;\n        }\n\n        // before or after\n        listeners = beforeChange ? descriptor._willChangeListeners : descriptor._changeListeners;\n        if(listeners && listeners._current) {\n            tokenName = listeners.specificHandlerMethodName;\n            if(Array.isArray(listeners._current)) {\n                if(listeners._current.length) {\n                    // notably, defaults to \"handleRangeChange\" or \"handleRangeWillChange\"\n                    // if token is \"\" (the default)\n\n                    descriptor.isActive = true;\n                    // dispatch each listener\n                    try {\n                            //removeGostListenersIfNeeded returns listeners.current or a new filtered one when conditions are met\n                            currentListeners = listeners.removeCurrentGostListenersIfNeeded();\n                            Ghost = ListenerGhost;\n                        for(i=0, countI = currentListeners.length;i<countI;i++) {\n                            if ((listener = currentListeners[i]) !== Ghost) {\n                                if (listener[tokenName]) {\n                                    listener[tokenName](plus, minus, index, this, beforeChange);\n                                } else if (listener.call) {\n                                    listener.call(this, plus, minus, index, this, beforeChange);\n                                } else {\n                                    throw new Error(\"Handler \" + listener + \" has no method \" + tokenName + \" and is not callable\");\n                                }\n                            }\n                        }\n                    } finally {\n                        descriptor.isActive = false;\n                    }\n                }\n            }\n            else {\n                descriptor.isActive = true;\n                // dispatch each listener\n                try {\n                    listener = listeners._current;\n                    if (listener[tokenName]) {\n                        listener[tokenName](plus, minus, index, this, beforeChange);\n                    } else if (listener.call) {\n                        listener.call(this, plus, minus, index, this, beforeChange);\n                    } else {\n                        throw new Error(\"Handler \" + listener + \" has no method \" + tokenName + \" and is not callable\");\n                    }\n                } finally {\n                    descriptor.isActive = false;\n                }\n\n            }\n        }\n\n    }\n};\n\nRangeChanges.prototype.addBeforeRangeChangeListener = function (listener, token) {\n    return this.addRangeChangeListener(listener, token, true);\n};\n\nRangeChanges.prototype.removeBeforeRangeChangeListener = function (listener, token) {\n    return this.removeRangeChangeListener(listener, token, true);\n};\n\nRangeChanges.prototype.dispatchBeforeRangeChange = function (plus, minus, index) {\n    return this.dispatchRangeChange(plus, minus, index, true);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}